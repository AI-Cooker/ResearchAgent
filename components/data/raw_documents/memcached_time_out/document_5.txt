Tuning Memcached Timeouts for a Cloud Environment - The Couchbase Blog
 
 
 
 Menu    
Products  
What is Couchbase?
	Couchbase is JSON database that excels in high volume transactions. Retailing on Black Friday? Running a lottery? We're here to help.
Why NoSQL
ProductsCapella Couchbase as a service
Server Our self-managed NoSQL database offering
MobileEmbedded NoSQL on your device, anywhere
Autonomous OperatorContainerized Couchbase
See how Capella stacks up
		Capella, Atlas, DynamoDB evaluated on 40 criteria
	
Compare
		Ready For Pricing?
	
		We’ve got you covered. Compare Couchbase pricing or ask a question.
	
Get Pricing
Solutions  
By IndustryEnergy & Utilities
Gaming
Healthcare
Entertainment
Retail
See all industries
By NeedRDBMS to NoSQL
Mobile & Edge
Choosing a Database
Caching
Field Service
See all use cases
Why NoSQL
		What is NoSQL and why choose it?
	
		Why successful enterprises rely on NoSQL
	
Learn more
Developers  
Popular DocsCapella Overview
Server Overview
Mobile & Edge Overview
Connecting Apps (SDKs)
Tutorials & Samples
Docs Home
Couchbase Developers
		Try code, get started with SDKs, and explore content tailored to your role.
	
Explore Now
Developer Playground
		Start a Capella session
	
		Try Couchbase Capella in a sandbox.
	
Start a Capella session
Learn  
Resource CenterWebcasts & Events
Videos & Presentations
Whitepapers
See all resources
EducationAcademy
Certification
Forums
Support Login
DocumentationCapella
Server
Mobile
Kubernetes
SDKs
Couchbase Certification
		Get Couchbase certified
	
		Get certified and bring your Couchbase knowledge to the database market.
	
Explore
Company  
AboutAbout Us
Leadership
Customers
Newsroom
Contact
Join UsCareers
Investors
Partners
Events
Our ServicesProfessional Services
Enterprise Support
Become an ISV Partner
		ISV Partner Program
	
		Learn about Couchbase's ISV Program and how to join.
	
Learn more
		Couchbase Customer Spotlight
	
		Marriott
	
		Marriott chose Couchbase over MongoDB and Cassandra for their reliable personalized customer experience.
	
Learn more
Try Free
Sign In
Pricing
 
Blog
Browse by Topic
Topics
Application Design
Data Modeling
Architecture
Performance
Best Practices & Tutorials
Security
Browse by Specialization
Specializations
Products
Capella
Server
Autonomous Operator
Mobile
Sync Gateway
Lite
SDKs
Java
.NET
Scala
Ruby
Node.js
Android
Python
PHP
Swift
GoLang
Objective-C
Capabilities
SQL++ (N1QL)
Multi-Dimensional Scaling
XDCR
Caching
Full-Text Search
Analytics
Indexing
Eventing
Backup
Search for:
 Search
 
Blog Sign In >
 
 
  NextSpymemcached Java and picking meaningful data points
Tuning Memcached Timeouts for a Cloud Environment
 
						Sean Lynch					
on
December 16, 2014
These days, more and more apps are running in the cloud, and they’re starting to take memcached with them. For example, as we announced earlier this week, nearly 300 applications are using NorthScale’s memcached as a service on Heroku’s Ruby-based PaaS cloud platform.
In the past, most environments using memcached have run it on a single, controlled LAN: usually the frontend web servers sitting on the DMZ, without even the normal firewall or router sitting between the DMZ and the database. In this environment, one can reasonably expect that server failures are far more likely than even a single dropped packet, and waiting for a retransmit is likely to take longer than a hit to the database, so it makes sense to set extremely aggressive timeouts, on the order of 100-250ms or less, for memcached operations.
In contrast, cloud networking environments tend to be far less controlled, since they’re shared with other customers, and even the location of a given service is not necessarily under the control of the user. In these environments, it’s not uncommon to have three or more hops between nodes, even in the same datacenter. And with other customers on the same switch or same physical node, one can expect to see the occasional burst of packet loss or high latency.
In such an environment, with even mildly aggressive timeouts, a single dropped packet can cause a query to fail. TCP’s initial retransmit timer is 3 seconds. The only way to try again faster than this is to give up and retry right away. Unless your database is slower than this or particularly expensive, it may make sense to leave your client’s timeouts set to their (probably relatively aggressive) defaults. However, since timeouts are now more likely to be caused by network issues than server failures, it’s important if your client marks servers dead after repeated failures that this be loosened a bit. 2 (the default in Fauna) is probably too tight; 3-5 is probably a better number of failures before marking a server dead.
A lot of applications that weren’t born in the cloud won’t handle timeouts from memcached very well. For such applications, you might consider tuning the timeouts to be able to handle at least a single dropped packet. The tunables for Fauna (the Ruby client NorthScale recommends since it supports SASL) can be passed as hash parameters to the client constructor. I’ve included recommendations for handling a single dropped packet:
:connect_timeout – 4.0 – initial connect, TCP will take 3 seconds if a packet is dropped
:rcv_timeout – not set – libmemcached equivalent is MEMCACHED_BEHAVIOR_RCV_TIMEOUT – time to get a response from the server
:poll_timeout – not set – libmemcached equivalent is MEMCACHED_BEHAVIOR_POLL_TIMEOUT – time we wait for the poll call to return
:timeout – 4.0 – default for the :rcv_timeout and :poll_timeout if they aren’t separately specofied; this is usually what’s used
:retry_timeout – 30 – how long to leave a server marked dead when it hits :server_failure_limit
:server_failure_limit – 3-5 – how many times a server can fail before it’s marked dead
All these are in seconds; Fauna does the conversion to the right value for libmemcached internally.
 
Sean Lynch 
 
Posted in:
Uncategorized 
Author
									Posted by								Sean Lynch
 All Posts
              Leave a comment            
 Hide comments
Leave a reply Cancel replyYou must be logged in to post a comment. 
Search our blog
Search for:
 Search
Recent Posts
Quer levar seu banco de dados para o próximo nível? (Portuguese)
How Couchbase Helps Customers Dramatically Reduce TCO
Securing Communication with TLS Certificates: A Definitive Guide for Couchbase Server (Part 2 of 3)
Your Guide to Scaling Microservices
Couchbase Capella Achieves PCI DSS 4.0 Compliance and CSA STAR Level Certifications
Top Posts
 App Development Costs (A Breakdown) 
 3 Reasons Customers Turn from MongoDB to Couchbase 
 What is Data Modeling? Conceptual, Physical, Logical 
 11 Fluent Bit Examples, Tips & Tricks for Log Forwarding with Couchbase 
 Application Development Life Cycle (Phases and Models) 
Blog TopicsBlog Topics
Select Topic
.NET
Analytics
Android
Application Design
Backup
Best Practices and Tutorials
Community
Company
Connectors
Couchbase Architecture
Couchbase Autonomous Operator
Couchbase Capella
Couchbase Connect
Couchbase Global Secondary Index
Couchbase Lite
Couchbase Mobile
Couchbase SDK
Couchbase Server
Culture
Customers
Data Modeling
Edge computing
Eventing
Executive
Flutter
Full-Text Search
Geospatial
Global Secondary Index
GoLang
Indexing
Java
JavaScript
Kotlin
Kubernetes
License
Monitoring
Multi-Dimensional Scaling
Node.js
Objective-C
Performance
PHP
Python
Ruby
Rust
Scala
Scopes and Collections
Security
Solutions
Spring
Spring Boot
SQL++ / N1QL Query
Swift
Sync Gateway
Text Analysis
Transactions
Uncategorized
Upgrades
Xamarin
XDCR
 
Stay informed about Couchbase Blogs
Please leave this field emptyEmail *
 By checking this box, you acknowledge our Privacy Policy. You may unsubscribe at any time.
            
Check your inbox or spam folder to confirm your subscription.
        
 
Documentation
Downloads
Forums
Blog
Resources
Support Login
Training
Careers
Events
SDKs
Twitter
LinkedIn
Github
StackOverflow
 
        © 2023        Couchbase, Inc. Couchbase, Couchbase Lite and the Couchbase logo are registered trademarks of Couchbase, Inc.
      
Terms of Use
Privacy Policy
Cookie Policy
Support Policy
Marketing Preference Center
 
